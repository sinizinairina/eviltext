// Generated by CoffeeScript 1.7.1
(function() {
  var __slice = [].slice;

  module.exports = {
    assignLogWeights: function(tagCloud, minSize, maxSize) {
      var constant, counts, maxCount, minCount, tag, weight, _i, _len, _results;
      if (minSize == null) {
        minSize = 90;
      }
      if (maxSize == null) {
        maxSize = 150;
      }
      counts = _(tagCloud).pluck('count');
      maxCount = _(counts).max();
      minCount = _(counts).min();
      constant = Math.log(maxCount - (minCount - 1)) / (maxSize - minSize || 1);
      _results = [];
      for (_i = 0, _len = tagCloud.length; _i < _len; _i++) {
        tag = tagCloud[_i];
        weight = minSize + Math.log(tag.count - (minCount - 1)) / constant;
        _results.push(tag.weight = Math.round(weight));
      }
      return _results;
    },
    postprocessHtml: function(html, _arg) {
      var $, base, cheerio, emptyImage, lazyImages, path, replaceRelativePaths;
      path = _arg.path, replaceRelativePaths = _arg.replaceRelativePaths, lazyImages = _arg.lazyImages;
      cheerio = require('cheerio');
      $ = cheerio.load(html);
      base = path.replace(/\/[^\/]+$/, '');
      if (replaceRelativePaths && !(base === '/' || base === '')) {
        $('a').each(function() {
          var e;
          e = $(this);
          return e.attr('href', app.pathUtil.expandRelativePath(e.attr('href'), base));
        });
        $('img').each(function() {
          var e;
          e = $(this);
          return e.attr('src', app.pathUtil.expandRelativePath(e.attr('src'), base));
        });
      }
      if (lazyImages) {
        emptyImage = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
        $('img').each(function() {
          var e;
          e = $(this);
          e.attr('data-src', e.attr('src'));
          e.attr('src', emptyImage);
          return e.attr('onload', "lazyImage(this)");
        });
      }
      return html = $.html();
    },
    parseHtml: function(html) {
      var $, cheerio, child, convert;
      convert = function(e) {
        var child;
        switch (e.type) {
          case 'tag':
            return {
              type: e.name,
              attributes: e.attribs || {},
              children: (function() {
                var _i, _len, _ref, _results;
                _ref = e.children;
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  child = _ref[_i];
                  _results.push(convert(child));
                }
                return _results;
              })()
            };
          case 'text':
            return {
              type: 'text',
              text: e.data
            };
          case 'script':
            return {
              type: 'text',
              text: ''
            };
          default:
            throw new Error("unknown element type '" + e.type + "'!}");
        }
      };
      cheerio = require('cheerio');
      $ = cheerio.load(html);
      return (function() {
        var _i, _len, _ref, _results;
        _ref = $._root.children;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          _results.push(convert(child));
        }
        return _results;
      })();
    },
    buildHtml: function(nodes) {
      var $, cheerio, convert, node, root, _i, _len;
      cheerio = require('cheerio');
      $ = cheerio.load('<div>');
      convert = function(node) {
        var child, e, name, value, _i, _len, _ref, _ref1;
        switch (node.type) {
          case 'text':
            return node.text;
          default:
            e = $("<" + node.type + ">");
            _ref = node.attributes;
            for (name in _ref) {
              value = _ref[name];
              e.attr(name, value);
            }
            _ref1 = node.children;
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              child = _ref1[_i];
              e.append(convert(child));
            }
            return e;
        }
      };
      root = $('div').first();
      for (_i = 0, _len = nodes.length; _i < _len; _i++) {
        node = nodes[_i];
        root.append(convert(node));
      }
      return root.html();
    },
    truncateText: function(text, options) {
      var availableLength, buff, char, hasAtLeastOneWord, i, lastToken, length, result, spaceRe, token, tokens, truncated, type, _i, _j, _len, _ref, _ref1, _ref2;
      if (options == null) {
        options = {};
      }
      spaceRe = /\s/;
      _ref = [[], null, []], tokens = _ref[0], type = _ref[1], buff = _ref[2];
      for (i = _i = 0, _ref1 = text.length - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        char = text.charAt(i);
        if (spaceRe.test(char)) {
          if (type !== 'space') {
            if (buff.length > 0) {
              tokens.push(buff.join(''));
            }
            type = 'space';
            buff = [];
          }
          buff.push(char);
        } else {
          if (type !== 'word') {
            if (buff.length > 0) {
              tokens.push(buff.join(''));
            }
            type = 'word';
            buff = [];
          }
          buff.push(char);
        }
      }
      if (buff.length > 0) {
        tokens.push(buff.join(''));
      }
      _ref2 = [[], 0, false, false], result = _ref2[0], length = _ref2[1], truncated = _ref2[2], hasAtLeastOneWord = _ref2[3];
      for (i = _j = 0, _len = tokens.length; _j < _len; i = ++_j) {
        token = tokens[i];
        if (spaceRe.test(token)) {
          if (i === 0 || i === (tokens.length - 1)) {
            result.push(token);
          } else {
            if (length + 1 <= options.max) {
              length += 1;
              result.push(token);
            } else {
              truncated = true;
              break;
            }
          }
        } else {
          if (length + token.length <= options.max) {
            length += token.length;
            result.push(token);
          } else {
            if (!hasAtLeastOneWord) {
              availableLength = options.max - length;
              token = token.slice(0, +(availableLength - 1) + 1 || 9e9);
              length += token.length;
              result.push(token);
            }
            truncated = true;
            break;
          }
          hasAtLeastOneWord = true;
        }
      }
      lastToken = result[result.length - 1];
      if ((result.length > 0) && (length > 0) && truncated && spaceRe.test(lastToken)) {
        result.pop();
        length -= 1;
      }
      return [result.join(''), length, truncated];
    },
    symbolLength: function(text) {
      return _s.strip(text).split(/\s/).join(' ').length;
    },
    truncateHtml: function(html, options) {
      var convert, convertedNode, convertedNodes, firstElementWithLength, isInlineCode, node, nodes, onlySpaceRe, totalLength, truncated, _i, _len, _ref;
      if (options == null) {
        options = {};
      }
      if (options.predefined == null) {
        options.predefined = {};
      }
      onlySpaceRe = /^\s+$/;
      nodes = this.parseHtml(html);
      isInlineCode = function(node) {
        return (node.type === 'code') && (node.children.length === 1) && (node.children[0].type === 'text') && !/\n/.test(node.children[0].text);
      };
      totalLength = 0;
      firstElementWithLength = true;
      convert = function(node) {
        var child, convertedChild, convertedNode, length, maxLength, text, tmp, truncated, _i, _len, _ref, _ref1, _ref2;
        if (node.type === 'text') {
          length = module.exports.symbolLength(node.text);
          if (!firstElementWithLength) {
            length += 1;
          }
          if (onlySpaceRe.test(node.text)) {
            return [node, false];
          } else if (totalLength + length <= options.max) {
            totalLength += length;
            firstElementWithLength = false;
            return [node, false];
          } else {
            if (options.min && totalLength < options.min) {
              maxLength = options.max - totalLength;
              if (!firstElementWithLength) {
                maxLength -= 1;
              }
              _ref = module.exports.truncateText(node.text, {
                max: maxLength
              }), text = _ref[0], length = _ref[1], tmp = 3 <= _ref.length ? __slice.call(_ref, 2) : [];
              if (!firstElementWithLength) {
                length += 1;
              }
              totalLength += length;
              firstElementWithLength = false;
              return [
                {
                  type: 'text',
                  text: text
                }, true
              ];
            } else {
              return [null, true];
            }
          }
        } else if (options.predefined && (length = options.predefined[node.type]) && !isInlineCode(node)) {
          if (!firstElementWithLength) {
            length += 1;
          }
          if (totalLength + length <= options.max) {
            totalLength += length;
            firstElementWithLength = false;
            return [node, false];
          } else {
            return [null, true];
          }
        } else {
          if (node.children.length > 0) {
            convertedNode = {
              type: node.type,
              attributes: node.attributes,
              children: []
            };
            truncated = false;
            _ref1 = node.children;
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              child = _ref1[_i];
              _ref2 = convert(child), convertedChild = _ref2[0], truncated = _ref2[1];
              if (convertedChild) {
                convertedNode.children.push(convertedChild);
              }
              if (truncated) {
                break;
              }
            }
            if (convertedNode.children.length > 0) {
              return [convertedNode, truncated];
            } else {
              return [null, true];
            }
          } else {
            return [node, false];
          }
        }
      };
      truncated = false;
      convertedNodes = [];
      for (_i = 0, _len = nodes.length; _i < _len; _i++) {
        node = nodes[_i];
        _ref = convert(node), convertedNode = _ref[0], truncated = _ref[1];
        if (convertedNode) {
          convertedNodes.push(convertedNode);
        }
        if (truncated) {
          break;
        }
      }
      return [this.buildHtml(convertedNodes), totalLength, truncated];
    },
    smartHtmlTruncate: function(html, max) {
      return this.truncateHtml(html, {
        max: max,
        min: Math.ceil(2 * max / 3),
        predefined: {
          img: Math.ceil(max / 2) + 1,
          pre: Math.ceil(max / 2) + 1,
          code: Math.ceil(max / 2) + 1,
          iframe: Math.ceil(max / 2) + 1
        }
      });
    },
    textLengthInString: function(string) {
      var match;
      match = encodeURIComponent(string).match(/%[89ABab]/g);
      return string.length + (match ? match.length : 0);
    },
    generateId: function(length) {
      var count, id, rand, symbols, _ref;
      if (length == null) {
        length = 16;
      }
      symbols = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
      _ref = ["", length + 1], id = _ref[0], count = _ref[1];
      while (count -= 1) {
        rand = Math.floor(Math.random() * symbols.length);
        id += symbols[rand];
      }
      return id;
    }
  };

}).call(this);
